RecursiveIterator = require 'recursive-iterator'
_ = require 'lodash'
{toFlatten} = require('chdl_utils')

module.exports={
  createSigArray: (type,number,width=1)->
    return (type(width) for i in [0...number])

  createChannelArray: (number)->
    return (channel() for i in [0...number])

  numWidth: (number)->
    Math.floor(Math.log2(number))+1

  $sigMux:(select,sig1,sig2)->
    selSig=local_wire(sig1.getWidth(),'sel')
    assign(selSig)
      $if(select) => $ sig1
      $else => $ sig2
      $endif
    return $ selSig
    
  $channelMux:(select,outChannel,inChannelList...)->
    for dst in outChannel.wireList()
      list=[]
      width=dst.net.getWidth()
      for src,index in inChannelList when dst.dir=='input'
        eq=$ (select==index)
        list.push($ expand(width,eq) & src.getWire(dst.path))
      if dst.dir=='input'
        assign(dst.net) = $join(list,(sum,i)=>$(sum+i))
      else if dst.dir=='output'
        for src,index in inChannelList
          assign(src.getWire(dst.path)) = $ dst.net

  mirrorPort:(i)->
    iterator=new RecursiveIterator(i)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function' and state.node.__type=='port'
        width=state.node.getWidth()
        if state.node.getType()=='input'
          _.set(out,state.path,output(width))
        else if state.node.getType()=='output'
          _.set(out,state.path,input(width))
      item = iterator.next()
    return out

  $portHub:(list...)->
    clone_list=list[...]
    i=0
    while i<clone_list.length
      dst=clone_list.shift()
      for [name,port] in toFlatten(dst)
        el=_.get(dst,name)
        if port.getType()=='input'
          for n in clone_list
            find=_.get(n,name)
            if find? and find.getType()=='output'
              assign(find) = el
      clone_list.push(dst)
      i+=1

  bundleClone:(i)->
    iterator=new RecursiveIterator(i)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function' and state.node.__type=='port'
        width=state.node.getWidth()
        if state.node.getType()=='input'
          _.set(out,state.path,input(width))
        else if state.node.getType()=='output'
          _.set(out,state.path,output(width))
      if state.node.constructor.name=='Function' and state.node.__type=='wire'
        width=state.node.getWidth()
        _.set(out,state.path,wire(width))
      if state.node.constructor.name=='Function' and state.node.__type=='reg'
        width=state.node.getWidth()
        _.set(out,state.path,reg(width))
      item = iterator.next()
    return out

  $bundleMap:(o,i,func)->
    iterator=new RecursiveIterator(o)
    item=iterator.next()
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='wire' or state.node.__type=='reg' or state.node.__type=='port'
          inWire=_.get(i,state.path)
          assign(state.node) => func(inWire)
      item = iterator.next()

  $bundleJoin:(o,list,func)->
    iterator=new RecursiveIterator(o)
    item=iterator.next()
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='wire' or state.node.__type=='reg' or state.node.__type=='port'
          sigList=[]
          for i in list
            sigList.push _.get(i,state.path).refName()
          assign(state.node)
            $reduce(sigList,(sum,item,first,last)=>
              if first
                $ item
              else
                func(sum,item)
            )
      item = iterator.next()

  $order: (list,defaultValue=0)->
    plist=[]
    for {cond,value} in list
      plist.push [cond,value()]
    plist.push(defaultValue)
    return $reduceRight(plist,(sum,item,first,last)=>
      if first
        $ item
      else
        $if(item[0])
          $ item[1]
        $else
          $ sum
        $endif
    )

  $join: (list,func)->
    return $reduce(list,(sum,item,first,last)=>
      if first
        $ item
      else
        func(sum,item)
    )

  $balance: (list,width=null) ->
    width=width ? @__assignWidth
    return $reduce(list,(sum,item,first,last)=>
      if(first)
        $ (expand(width,item.cond)&(item.value()))
      else
        $ sum|(expand(width,item.cond)&(item.value()))
        )

  $doubleSync: (sigIn,clock=null)->
    width=sigIn.getWidth()
    if clock?
      d1 = local_reg(width,'sync').clock(clock).noReset()
      d2 = local_reg(width,'sync').clock(clock).noReset()
    else
      d1 = local_reg(width,'sync').noReset()
      d2 = local_reg(width,'sync').noReset()
    assign(d1) = $ sigIn
    assign(d2) = $ d1
    return $ d2

  $tripleSync: (sigIn,clock=null)->
    width=sigIn.getWidth()
    if clock?
      d1 = local_reg(width,'sync').clock(clock).noReset()
      d2 = local_reg(width,'sync').clock(clock).noReset()
      d3 = local_reg(width,'sync').clock(clock).noReset()
    else
      d1 = local_reg(width,'sync').noReset()
      d2 = local_reg(width,'sync').noReset()
      d3 = local_reg(width,'sync').noReset()
    assign(d1) = $ sigIn
    assign(d2) = $ d1
    assign(d3) = $ d2
    return $ d3

  $bundleAssign:(from,to)->
    iterator=new RecursiveIterator(from)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='port' or state.node.__type=='wire' or state.node.__type=='reg'
          toPoint=_.get(to,state.path)
          assign(state.node) = $ toPoint
      item = iterator.next()

  $grayNextCode: (code_word)->
    width = code_word.getWidth()+1
    w= local_wire(width)
    assign(w) = $ code_word + 1
    gray_code=new Array(width-1)
    for i in [0...width-1]
      gray_code[i]=$ w(i+1) ^ w(i)
    return $ cat(w.fromMsb(1),gray_code.reverse()...)

  $arrayMuxSet: (array,select,din)->
    len=array.length
    for i in [0...len]
      $if(i==select)
        assign(array[i]) = $ din
      $endif

  $arrayDecode: (array,select,width=null)->
    len=array.length
    list=[]
    for i in [0...len]
      list.push($cond(i==select) =>array[i])
    $balance(list,width)

  $rise: (sig,clock=null)->
    if clock?
      d1 = local_reg(1,'r_').clock(clock).noReset()
    else
      d1 = local_reg(1,'r_').noReset()
    assign(d1) = $ sig
    return $ (sig & (!d1))

  $fall: (sig,clock=null)->
    if clock?
      d1 = local_reg(1,'f_').clock(clock).noReset()
    else
      d1 = local_reg(1,'f_').noReset()
    assign(d1) = $ sig
    return $ ((!sig) & d1)

  $divider: (clk,n)->
    width=Math.ceil(Math.log2(n))
    cnt = local_reg(width,'cnt')
    assign(cnt)
      $if(cnt=={n-1}) => $ 0
      $else => $ cnt+1
      $endif
    return  $ cnt=={n-1}

  $count: (n,enable,clock=null,reset=null)->
    width=Math.ceil(Math.log2(n))
    if clock?
      cnt = local_reg(width,'cnt').clock(clock).reset(reset)
    else
      cnt = local_reg(width,'cnt')
    assign(cnt)
      $if(enable)
        $if(cnt=={n-1}) => $ 0
        $else => $ cnt+1
        $endif
      $else => $ 0
      $endif
    return  $ cnt=={n-1}

  $hold1: (sig,clear,clock=null,reset=null)->
    out = local_wire(1,'hold')
    if clock?
      latch = local_reg(1,'hold').clock(clock).reset(reset)
    else
      latch = local_reg(1,'hold')
    assign(out) = $ sig | latch
    always
      $if(clear)
        assign(latch) = $ 0
      $elseif(sig==1)
        assign(latch) = $ 1
      $endif
    return  $ out

  $hold0: (sig,clear,clock=null,reset=null)->
    out = local_wire(1,'hold')
    if clock?
      latch = local_reg(1,'hold').clock(clock).reset(reset)
    else
      latch = local_reg(1,'hold')
    assign(out) = $ sig & latch
    always
      $if(clear)
        assign(latch) = $ 1
      $elseif(sig==0)
        assign(latch) = $ 0
      $endif
    return  $ out

  $holdData: (sig,enable,clock=null,reset=null)->
    out = local_wire(sig.getWidth(),'hold')
    if clock?
      latch = local_reg(sig.getWidth(),'hold').clock(clock).reset(reset)
    else
      latch = local_reg(sig.getWidth(),'hold')
    assign(out)
      $if(enable) => $ sig
      $else => $ latch
      $endif

    always
      $if(enable)
        assign(latch) = $ sig
      $endif
    return  $ out

}
