RecursiveIterator = require 'recursive-iterator'
_ = require 'lodash'

module.exports={
  createSigArray: (type,number,width=1)->
    return (type(width) for i in [0...number])

  createChannelArray: (number)->
    return (channel() for i in [0...number])

  $channelMux:(select,outChannel,inChannelList...)->
    for dst in outChannel.wireList()
      list=[]
      width=dst.net.getWidth()
      for src,index in inChannelList when dst.dir=='input'
        eq=$ (select==index)
        list.push($ expand(width,eq) & src.getWire(dst.path))
      if dst.dir=='input'
        assign(dst.net) = $ op_reduce(list,"|")
      else if dst.dir=='output'
        for src,index in inChannelList
          assign(src.getWire(dst.path)) = $ dst.net

  mirrorPort:(i)->
    iterator=new RecursiveIterator(i)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function' and state.node.__type=='port'
        width=state.node.getWidth()
        if state.node.getType()=='input'
          _.set(out,state.path,output(width))
        else if state.node.getType()=='output'
          _.set(out,state.path,input(width))
      item = iterator.next()
    return out

  bundleClone:(i)->
    iterator=new RecursiveIterator(i)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function' and state.node.__type=='port'
        width=state.node.getWidth()
        if state.node.getType()=='input'
          _.set(out,state.path,input(width))
        else if state.node.getType()=='output'
          _.set(out,state.path,output(width))
      if state.node.constructor.name=='Function' and state.node.__type=='wire'
        width=state.node.getWidth()
        _.set(out,state.path,wire(width))
      if state.node.constructor.name=='Function' and state.node.__type=='reg'
        width=state.node.getWidth()
        _.set(out,state.path,reg(width))
      item = iterator.next()
    return out

  $bundleUniOp:(op,o,i)->
    iterator=new RecursiveIterator(o)
    item=iterator.next()
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='wire' or state.node.__type=='reg' or state.node.__type=='port'
          inWire=_.get(i,state.path)
          assign(state.node)
            if op=='&'
              $ {op} (inWire)
            else if op=='|'
              $ {op} (inWire)
            else if op=='~'
              $ {op} (inWire)
            else if op=='^'
              $ {op} (inWire)
      item = iterator.next()

  $bundleReduceOp:(op,o,list)->
    iterator=new RecursiveIterator(o)
    item=iterator.next()
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='wire' or state.node.__type=='reg' or state.node.__type=='port'
          sigList=[]
          for i in list
            sigList.push _.get(i,state.path).refName()
          assign(state.node)
            $reduce(sigList,(sum,item,first,last)=>
              if first
                $ item
              else
                if op=='+'
                  $ sum + item
                else if op=='-'
                  $ sum - item
                else if op=='*'
                  $ sum * item
                else if op=='^'
                  $ sum ^ item
            )
      item = iterator.next()

  $order: (list,defaultValue=0)->
    plist=[]
    for {cond,value} in list
      plist.push [cond,value]
    plist.push(defaultValue)
    return $reduceRight(plist,(sum,item,first,last)=>
      if first
        $ item
      else
        $if(item[0])
          $ item[1]
        $else
          $ sum
        $endif
    )

  $opJoin: (op,list)->
    return $reduce(list,(sum,item,first,last)=>
      if first
        $ item
      else
        if op=='+'
          $ sum + item
        else if op=='-'
          $ sum - item
        else if op=='*'
          $ sum * item
        else if op=='^'
          $ sum ^ item
        else if op=='&&'
          $ sum && item
        else if op=='||'
          $ sum || item
        else if op=='&'
          $ sum & item
        else if op=='|'
          $ sum | item
    )

  $balance: (list,width=null) ->
    width=width ? @__assignWidth
    return $reduce(list,(sum,item,first,last)=>
      if(first)
        $ (expand(width,item.cond)&(item.value))
      else
        $ sum|(expand(width,item.cond)&(item.value))
        )

  $doubleSync: (sigIn,clock=null)->
    pipeline(sigIn,{clock:clock}).next((pipe)=>
      assign_pipe('d1',sigIn.getWidth()) = $ sigIn
    ).next( (pipe)=>
      assign_pipe('d2',sigIn.getWidth()) = $ pipe.d1
    ).final( (pipe)=>
      $ pipe.d2
    )

  $tripleSync: (sigIn,clock=null)->
    pipeline(sigIn,{clock:clock}).next((pipe)=>
      assign_pipe('d1',sigIn.getWidth()) = $ sigIn
    ).next( (pipe)=>
      assign_pipe('d2',sigIn.getWidth()) = $ pipe.d1
    ).next( (pipe)=>
      assign_pipe('d3',sigIn.getWidth()) = $ pipe.d2
    ).final( (pipe)=>
      $ pipe.d3
    )

  $bundleAssign:(from,to)->
    iterator=new RecursiveIterator(from)
    item=iterator.next()
    out={}
    while !item.done
      state = item.value
      if state.node.constructor.name=='Function'
        if state.node.__type=='port' or state.node.__type=='wire' or state.node.__type=='reg'
          toPoint=_.get(to,state.path)
          assign(state.node) = $ toPoint
      item = iterator.next()
}
