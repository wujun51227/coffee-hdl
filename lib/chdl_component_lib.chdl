RecursiveIterator = require 'recursive-iterator'
_ = require 'lodash'

module.exports={
  $fifo: (depth,din,push,pop,clear)->
    width=din.getWidth()
    addrWidth = Math.floor(Math.log2(depth))+1
    Exponential_Full_Flag= depth==(2**addrWidth)
    level      = local_reg(addrWidth+1,'level')
    full       = local_reg(1,'full')
    raddr      = local_reg(addrWidth,'raddr')
    waddr      = local_reg(addrWidth,'waddr')
    empty_flag = local_reg().init(1)
    prefetched = local_reg()
    fifoUnit = (w)=> local_reg(w,'rff')
    rff_data= @createSigArray(fifoUnit,depth,width)
    rd_data= local_reg(width,'rd_data')

    read = local_wire(1,'read')
    assign(read)  = $ !empty_flag && (pop || !prefetched)

    empty = $ !prefetched
    dout = $ rd_data

    next_level= local_wire(addrWidth+1,'next_level')
    pass_always
      $if(pop==0&&push==1)
        assign(next_level) = $ level+1
      $elseif(pop==1&&push==0)
        assign(next_level) = $ level-1
      $else
        assign(next_level) = $ level
      $endif

    always
      $if(clear)
        assign(empty_flag) = $ 1
        assign(prefetched) = $ 0
      $else
        assign(empty_flag) = $ !next_level
        assign(prefetched)
          $if(cat(pop,read)==2\b01) => $ 1
          $elseif(cat(pop,read)==2\b10) => $ 0
          $else => $ prefetched
          $endif
      $endif

    rdata= local_wire(width,'rdata')

    assign(rdata) = $arrayDecode(rff_data,raddr)

    always
      $if(read)
        assign(rd_data) = $ rdata
      $endif
      $if(push)
        $arrayMuxSet(rff_data,waddr,din)
      $endif

    if(Exponential_Full_Flag)
      always
        $if(clear)
          assign(waddr) = $ 0
          assign(raddr) = $ 0
          assign(level) = $ 0
          assign(full) = $ 0
        $else
          assign(level) = $ next_level
          assign(full) = $ next_level(addrWidth)
          $if(push)
            assign(waddr) = $ waddr+1
          $endif
          $if(read)
            assign(raddr) = $ raddr+1
          $endif
        $endif
    else
      always
        $if(clear)
          assign(waddr) = $ 0
          assign(raddr) = $ 0
          assign(level) = $ 0
          assign(full) = $ 0
        $else
          assign(full) = $ depth==next_level
          $if(push)
            assign(waddr)
              $if((depth-1)==waddr) => $ 0
              $else => $ waddr+1
              $endif
          $endif
          $if(read)
            assign(raddr)
              $if((depth-1)==raddr) => $ 0
              $else => $ raddr+1
              $endif
          $endif
        $endif

    return {
      empty: $ empty
      full: $ full
      dout: $ dout
      level: $ level
    }

  $asyncFifo: (depth,din,push,pop)->
    width=din.getWidth()
    addrWidth = Math.floor(Math.log2(depth))+1
    clkw=push.getClock()
    rstw=push.getReset()
    clkr=pop.getClock()
    rstr=pop.getReset()
    if clkw==null or rstw==null
      throw new Error("Please attch clock/reset to #{push.getName()}")
    if clkr==null or rstr==null
      throw new Error("Please attch clock/reset to #{pop.getName()}")

    prefetched = local_reg(1,'prefetched').clock(clkr).asyncReset(rstr)
    empty_flag = local_reg(1,'empty_flag').clock(clkr).asyncReset(rstr)
    read = local_wire(1,'read')

    assign(read) = $ !empty_flag && ( pop || !prefetched)
    empty = $ !prefetched

    w={
      code: local_reg(addrWidth+1,'w_code').clock(clkw).asyncReset(rstw)
      rd_s1: local_reg(addrWidth+1,'rd_s1').clock(clkw).asyncReset(rstw)
      rd_s0: local_reg(addrWidth+1,'rd_s0').clock(clkw).asyncReset(rstw)
    }

    r={
      code: local_reg(addrWidth+1,'r_code').clock(clkr).asyncReset(rstr)
      wr_s1: local_reg(addrWidth+1,'wr_s1').clock(clkr).asyncReset(rstr)
      wr_s0: local_reg(addrWidth+1,'wr_s0').clock(clkr).asyncReset(rstr)
    }

    next_rd = local_wire(addrWidth+1,'next_rd')
    next_wr = local_wire(addrWidth+1,'next_wr')

    succeeding_code_rd = local_wire(addrWidth+1)
    succeeding_code_wr = local_wire(addrWidth+1)

    assign(succeeding_code_rd)
      $if(read) => $ next_rd
      $else => $ r.code
      $endif

    assign(succeeding_code_wr)
      $if(push) => $ next_wr
      $else => $ w.code
      $endif

    rd_addr = local_wire(addrWidth,'rd_addr')
    assign(rd_addr) = $ cat($opPrefix('^',r.code.fromMsb(2)) , r.code.fromLsb(addrWidth-1))

    wr_addr = local_wire(addrWidth,'wr_addr')
    assign(wr_addr) = $ cat( $opPrefix('^',w.code.fromMsb(2)) , w.code.fromLsb(addrWidth-1))

    always
      $if(cat(pop,read)==2\b01)
        assign(prefetched) = $ 1
      $elseif(cat(pop,read)==2\b10)
        assign(prefetched) = $ 0
      $endif

    assign(empty_flag) = $ succeeding_code_rd == r.wr_s1

    assign(r.wr_s1) = $ r.wr_s0
    assign(r.wr_s0) = $ w.code
    assign(r.code) = $ succeeding_code_rd

    assign(w.rd_s1) = $ w.rd_s0
    assign(w.rd_s0) = $ r.code
    assign(w.code) = $ succeeding_code_wr

    full = local_reg(1,'full').clock(clkw).asyncReset(rstw)
    assign(full) = $ succeeding_code_wr == cat($opPrefix('~',w.rd_s1.fromMsb(2)) ,w.rd_s1.fromLsb(addrWidth-1))

    assign(next_rd) = $grayNextCode(r.code)
    assign(next_wr) = $grayNextCode(w.code)

    aff_data = (local_reg(width,'aff').clock(clkw).noReset() for i in [0...depth])

    rdata= local_reg(width,'rdata').clock(clkr).noReset()

    assign(rdata)
      $if(read)
        $arrayDecode(aff_data,rd_addr)
      $else
        $ rdata
      $endif

    always
      $if(push)
        $arrayMuxSet(aff_data,wr_addr,din)
      $endif

    return {
      dout: $ rdata
      empty: $ empty
      full: $ full
    }

}
